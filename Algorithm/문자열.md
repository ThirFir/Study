# <strong>문자열</strong>
## <strong>KMP 알고리즘(Knuth-Morris-Pratt)</strong>
<p>문자열 검색 알고리즘. 주어진 문자열(H)이 어떤 특정한 부분 문자열(N)을 포함하는지 검사하는 알고리즘으로, 중복으로 검사되는 부분을 최소화하여 효율적인 검사를 수행할 수 있도록 하는 알고리즘이다.</p>

<br/>일반적인 문자열 검사는 다음의 과정으로 이루어진다. <small>(전체 문자열H : AABAABABABBCA, 부분 문자열N : ABAB)</small>


| |A|A|B|A|A|B|A|B|A|B|B|C|A|
|---:|---|---|---|---|---|---|---|---|---|---|---|---|---|
|1|**A**|B|A|B|
|2|**A**|~~B~~|A|B|
|3| |**A**|B|A|B|
|4| |**A**|**B**|A|B|
|5| |**A**|**B**|**A**|B|
|6| |**A**|**B**|**A**|~~B~~|
|7| | |~~A~~|B|A|B|
|8| | | |**A**|B|A|B|
|9| | | |**A**|~~B~~|A|B|
|10| | | | |**A**|B|A|B|
|11| | | | |**A**|**B**|A|B|
|12| | | | |**A**|**B**|**A**|B|
|13| | | | |**A**|**B**|**A**|**B**|
|14| | | | | |~~A~~|B|A|B|
|.|.|.|.|.|.|.|.|.|.|.|.|.|.|
| | | | | | | | | | |~~A~~|B|A|B|

```
int begin = 0;      // H문자열의 시작 위치
while(begin <= H.size() - N.size()){
    for(int j = 0; j < N.size(); ++j){
        if(N[j] != H[begin + j]){       // 일치하지 않으면 다음 시작 위치부터 재개
            ++begin;
            break;
        }
        else{
            if(j == N.size() - 1){      // 모든 문자가 일치하면
                ...
            }
        }
    }
}
```
<p>H 문자열의 처음에서 시작하여, N 문자열과의 비교에서 불일치가 발생하면 시작 위치를 한 칸 씩 이동해가며 모든 문자열을 검사하는 방식이며, 위 방식으로는 O(|H| X |N|)만큼의 시간복잡도가 발생한다. 위 방식에서의 문제점은 이전 위치에서의 검사 이후, 검사해보지 않더라도 일치하지 않는 부분이 있음을 판단할 수 있는 검사를 추가적으로 진행하는 것이다. 위 표에서 7번째 순서의 검사를 보자. 그 이전, 3 ~ 6번째 검사(begin = 1 또는 H[1])에서 답이 아님을 확인하고, begin을 한 칸 오른쪽으로 이동시킨 모습이다. 그러나 우리는 한 칸을 이동시켜봤자, 그 위치(H[2])에서 시작된 검사에서는 답일 수가 없음을 알 수 있다. N[0]는 A지만 H[2]는 B임을 이전 검사들을 통해 이미 알고 있기 때문이다. 그리고 H[2]가 아닌 H[3]에서 다음 검사를 시작해야만 답일 가능성이 있음을 판단할 수 있다. 그렇다면 이 알고 있는 정보를 통해 안해도 될 검사를 생략시킬 필요가 있다.</p>
<br/>

### **[KMP 알고리즘을 이용한 검사]**
<p> KMP 알고리즘은 불일치가 일어났을 때, 지금까지 일치한 글자의 수를 이용해 다음 검사 위치를 찾아낸다. 다음 그림을 보자. <br/>(행은 검사 순서와 상관없음, H : AABAABABAABCAABBC / N : BAABABAC)</p>

| |0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|1|A|A|B|A|A|B|A|B|A|A|B|C|A|A|B|B|C|
|2| | |**B**|**A**|**A**|**B**|**A**|**B**|**A**|~~C~~|| | | | | | |
|3| | | | | | | |**B**|**A**|A|B|A|B|A|C|

<p>H와 일치한 부분인 BAABABA를 보자. 이 BAABABA에서 접두사와 접미사가 동일한 최대 길이는 2열 3열의 BA와 7열 8열의 BA, 즉 2이다. 우리는 이 동일한 길이 2 만큼을 제외한 나머지 위치에서의 검사는 생략할 수 있게 된다. 접두사와 접미사가 동일하지 않으면, 검사를 진행해봐야 불일치가 발생할 수 밖에 없기 때문이다. 따라서 나머지 검사는 생략한 채 바로 H[7]의 위치에서 검사를 시작할 수 있다. 추가적으로, 이미 접두/접미사 BA는 일치함을 알고있으므로, 실제 검사는 접두사 BA를 생략하고 N[2...]를 H[9]부터 시작한다.</p>

```
vector<int> kmpSearch(const string& H, const string& N){
    int n = H.size(), m = N.size();
    vector<int> ret;
    // pi[i] = N[..i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이
    vector<int> pi = getPartialMatch(N);
    int begin = 0, matched = 0;     // begin : 검사의 시작 위치, matched : 문자열이 일치한 길이
    while(begin <= n - m){
        if(matched < m && H[begin + matched] == N[matched]){
            ++matched;
            if(matched == m) ret.push_back(begin);  // 모두 일치
        }
        else{
            if(matched == 0) ++begin;
            else{
                begin += matched - pi[matched - 1];
                matched = pi[matched - 1];      // 일치한 접두사(접미사)만큼은 생략해도 됨.
            }
        }
    }
}
```
<br/>

### **[부분 일치 테이블]**
<p> 그렇다면 이제는 H와 일치한 부분 문자열 중에서 접두사와 접미사가 동일한 최대의 길이 pi[i]를 알아낼 필요가 있다. </p>

```
vector<int> getPartialMatchNaive(const String& N){
    int m = N.size();
    vector<int> pi(m,0);
    for(int begin = 1; begin < m; ++begin){
        for(int i = 0; i + begin < m; ++i){
            if(N[begin + i] != N[i]) break;
            pi[begin + i] = max(pi[begin + i], i + 1);
        }
    }
}
```

문자열 N을 한 칸씩 이동시켜가며 N자기 자신과 비교해가며 탐색하는 방법으로, <strong>O(|N|^2)</strong>의 시간복잡도를 가진다.
0이 아닌 begin의 위치에서 시작한 문자열N이 이동시키지 않은(begin = 0) 문자열과 i+1글자만큼 일치한다는 것은 (i=0 일 때 한글자를 비교하므로 +1) 문자열 N[..i]의 접두사와 문자열N[..begin + i]의 접미사가 동일하다는 의미이고, 즉, N[..begin + i]의 최대 동일 접두사 접미사의 길이인 p[begin + i] = i + 1임을 나타낸다. 반복 과정에서 begin + i는 중복되어 반복될 수 있으므로 이전 계산값과 현재 계산값을 max를 취하여 값을 구한다.
<br/><br/>

#### **KMP 알고리즘을 이용한 부분 일치 테이블 생성**
KMP 알고리즘을 이용하여 부분 일치 테이블을 생성할 수도 있다.

```
vector<int> getPartialMatch(const string& N){
    int m = N.size();
    vector<int> pi(m,0);
    
    int begin = 1, matched = 0;
    while(begin + matched < m){
        if(N[begin + matched] == N[matched]){
            ++matched;
            pi[begin + matched - 1] = matched;
        }
        else{
            if(matched == 0) ++begin;
            else{
                begin += matched - pi[matched - 1];
                matched = pi[matched - 1];
            }
        }
    }
}
```
이때, 일치된 글자만큼 begin을 이동시키므로, pi의 계산에서 max를 취할 필요가 없음을 알 수 있다. 
<br/>위 방식으로 <strong>O(|N|)</strong>의 시간복잡도를 가지며, 총 <strong>O(|N| + |H|)</strong>의 시간복잡도를 가진다.
