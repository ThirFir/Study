# <strong>0. 선형 자료 구조?</strong>
일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 자료 구조는 배열이다. '동적 배열'과 '연결 리스트'는 배열과 같이 일렬로 늘어선 자료들을 더 효율적으로 활용할 수 있게 도와주는 자료 구조이다.

## <strong>I. 동적 배열</strong>
배열의 가장 큰 문제 중 하나는 처음 선언 시에 크기를 지정해야 하며, 그 이상의 자료는 집어넣을 수 없다는 점이다. 이 문제를 해결하기 위해 고안된 것이 바로 동적 배열이다. 대게 언어의 표준 라이브러리에 포함되어 있으며, 이 동적 배열은 배열을 통해 만들어낸 별도의 자료 구조이다.

### <strong>특성</strong>
1. 원소들은 메모리의 연속된 위치에 저장된다.
2. 주어진 위치에 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.
3. **배열의 크기를 변경하는 resize() 연산이 가능하다. O(N)의 시간이 소모된다.** 
4. **주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append() 연산을 지원한다. O(1)의 시간이 소모된다.**

### <strong>구현</strong>
3, 4번의 연산을 구현하기 위해 동적 배열은 동적으로 할당받은 배열을 사용한다. 크기를 바꾸기 위해 단순히 새 배열에 기존 원소들을 복사하고, 그 배열을 참조하도록 바꾼다. 일반적으로 동적 배열 클래스는 다음의 값들을 가지고 있다.
> int size; &nbsp;&nbsp;&nbsp;&nbsp;// 배열의 크기<br>
> ElementType* array; &nbsp;&nbsp;&nbsp;&nbsp;// 실제 배열을 가리키는 포인터

동적 배열에는 크기(Size) 외에 '용량(Capacity)'이라는 개념이 존재한다. 크기는 배열이 현재 사용하고 있는 이는 재할당 시에 소모되는 시간을 상수 시간으로 줄이기 위한 전략으로, 만약 재할당을 할 때 딱 필요분 만큼만 크기를 확보한다면, 다음 재할당 시에 다시 선형 시간이 필요하게 되므로 이를 방지하기 위해 용량이라는 여유분을 추가 확보한다. 그리하여 이 확보된 만큼의 용량마저 크기로써 전부 사용하게 된다면 다시 새 용량을 확보하는 방식이다. 이렇게 한다면 상수 시간에 append()를 구현할 수 있다. 새로 확보되는 용량은 이전 용량의 2배이다.

## <strong>II. 연결 리스트</strong>
배열 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나 삭제하는 것은 평균적인 시간이 오래걸리는 작업이다. 해당 위치 앞, 뒤의 원소들을 옮기는 작업이 추가적으로 수반되기 때문이다. 이를 해결하기 위해 고안된 자료구조가 바로 연결 리스트이다. 마찬가지로 대게 언어의 표준 라이브러리에 포함되어 있다.

### <strong>특성</strong>
1. 원소들이 메모리의 연속된 위치에 저장되지 않고 여기저기 흩어져 있다.
2. 특정 위치에 삽입 및 삭제가 O(1)의 시간에 가능하다.
3. i번째 노드를 찾아내는 데에 O(N)의 시간이 소모된다.
4. 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다. (삭제한 순서의 반대로 복구가 이루어져야만 한다.)

### <strong>구현</strong>
각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있다.
> struct ListNode { <br/>
> &nbsp;&nbsp;&nbsp;&nbsp;int element; &nbsp;&nbsp;&nbsp;&nbsp;// 담고 있는 원소 <br/>
> &nbsp;&nbsp;&nbsp;&nbsp;ListNode *prev, next; &nbsp;&nbsp;&nbsp;&nbsp;// 이전, 다음 노드의 포인터<br/>
> };

특정 위치에 노드를 삽입, 삭제하는 방법은, '새 노드의 prev, next 노드 포인터'와 '이전 노드의 next 포인터', '다음 노드의 prev 포인터'를 바꿔줌으로써 O(1)의 시간만에 이루어진다. 