# <strong>0. 선형 자료 구조?</strong>
일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 자료 구조는 배열이다. '동적 배열'과 '연결 리스트'는 배열과 같이 일렬로 늘어선 자료들을 더 효율적으로 활용할 수 있게 도와주는 자료 구조이다.

## <strong>I. 동적 배열</strong>
배열의 가장 큰 문제 중 하나는 처음 선언 시에 크기를 지정해야 하며, 그 이상의 자료는 집어넣을 수 없다는 점이다. 이 문제를 해결하기 위해 고안된 것이 바로 동적 배열이다. 대게 언어의 표준 라이브러리에 포함되어 있으며, 이 동적 배열은 배열을 통해 만들어낸 별도의 자료 구조이다.

### <strong>특성</strong>
1. 원소들은 메모리의 연속된 위치에 저장된다.
2. 주어진 위치에 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.
3. **배열의 크기를 변경하는 resize() 연산이 가능하다. O(N)의 시간이 소모된다.** 
4. **주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append() 연산을 지원한다. O(1)의 시간이 소모된다.**

### <strong>구현</strong>
3, 4번의 연산을 구현하기 위해 동적 배열은 동적으로 할당받은 배열을 사용한다. 크기를 바꾸기 위해 단순히 새 배열에 기존 원소들을 복사하고, 그 배열을 참조하도록 바꾼다. 일반적으로 동적 배열 클래스는 다음의 값들을 가지고 있다.
```
int size;               // 배열의 크기
ElementType* array;     // 실제 배열을 가리키는 포인터
```
동적 배열에는 크기(Size) 외에 '용량(Capacity)'이라는 개념이 존재한다. 크기는 배열이 현재 사용하고 있는 이는 재할당 시에 소모되는 시간을 상수 시간으로 줄이기 위한 전략으로, 만약 재할당을 할 때 딱 필요분 만큼만 크기를 확보한다면, 다음 재할당 시에 다시 선형 시간이 필요하게 되므로 이를 방지하기 위해 용량이라는 여유분을 추가 확보한다. 그리하여 이 확보된 만큼의 용량마저 크기로써 전부 사용하게 된다면 다시 새 용량을 확보하는 방식이다. 이렇게 한다면 상수 시간에 append()를 구현할 수 있다. 새로 확보되는 용량은 이전 용량의 2배이다.
<br/><br/>
## <strong>II. 연결 리스트</strong>
배열 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나 삭제하는 것은 평균적인 시간이 오래걸리는 작업이다. 해당 위치 앞, 뒤의 원소들을 옮기는 작업이 추가적으로 수반되기 때문이다. 이를 해결하기 위해 고안된 자료구조가 바로 연결 리스트이다. 마찬가지로 대게 언어의 표준 라이브러리에 포함되어 있다.

### <strong>특성</strong>
1. 원소들이 메모리의 연속된 위치에 저장되지 않고 여기저기 흩어져 있다.
2. 특정 노드를 찾아내는 데에 O(N)의 시간이 소모된다.
3. 원소를 삽입, 삭제하더라도 다른 원소들의 이동이 변함이 없다.
4. 다른 원소들은 그대로 유지한 채로 특정 위치에 삽입 및 삭제에 O(1)의 시간이 소모된다. (단, 위치의 탐색에 O(N)의 시간이 소모된다.)
5. 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다. (삭제한 순서의 반대로 복구가 이루어져야만 한다.)

### <strong>구현</strong>
각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있다.
``` 
struct ListNode {
    int element;            // 담고 있는 원소
    ListNode *prev, next;   // 이전, 다음 노드의 포인터<br/>
};
```
특정 위치에 노드를 삽입, 삭제하는 방법은, '새 노드의 prev, next 노드 포인터'와 '이전 노드의 next 포인터', '다음 노드의 prev 포인터'를 바꿔줌으로써 O(1)의 시간만에 이루어진다. 
<br/><br/><br/>
# <strong>1. 큐와 스택</strong>
일렬로 늘어선 자료들을 표현하는 자료 구조이다. 이때 자료는 특정한 순서로만 넣거나 꺼낼 수 있다. 이 같은 연산들은 사실 배열이나 연결리스트를 통해 쉽게 구현할 수 있지만, 그 자료 구조의 형태에 이름을 붙임으로써 개발자간 의사소통이나 프로그램의 설계에 좋은 효과를 일으킬 수 있게 되었다.

### <strong>특성</strong>

#### <strong>큐(Queue)</strong>
>자료를 한쪽 끝에서 넣고 반대쪽 끝에서 꺼낼 수 있는 자료 구조. 가장 먼저 들어간 자료가 가장 먼저 꺼내져 나온다. 이 속성을 선입선출(FIFO, First In First Out)이라 부른다.
#### <strong>스택(Stack)</strong>
>한쪽 끝에서만 자료를 넣고 뺄 수 있다. 가장 늦게 들어간 자료가 가장 먼저 꺼내지며, 이 속성을 후입선출(LIFO, Last In First Out)이라 부른다.
#### <strong>데크(Dequeue)</strong>
>양쪽 끝에서 자료를 넣고 뺄 수 있다.

자료를 넣는 작업을 push, 자료를 꺼내는 작업을 pop이라고 부르며, 위의 각 자료 구조에서 이들 연산은 O(1)의 시간에 이루어진다.

### <strong>사용법 (C++)</strong>

#### <strong>큐(Queue)</strong>
```
#include <queue>        // 헤더 파일

queue<TYPE> queue;      // 선언

queue.push(element);    // element 추가
queue.pop();            // front 데이터 삭제
queue.front();          // front 데이터 반환
queue.back();           // back 데이터 반환
queue.size();           // 큐의 크기 반환
queue.empty();          // 비어있는지 확인

swap(q1,q2);            // 두 큐의 내용을 바꿈
```
#### <strong>스택(Stack)</strong>
```
#include <stack>        // 헤더 파일

stack<TYPE> stack;      // 선언

stack.push(element);    // element 추가
stack.pop();            // 최상위 데이터 삭제
stack.top();            // 최상위 데이터 반환
stack.size();           // 스택 크기 반환
stack.empty();          // 비어있는지 확인

swap(s1,s2);            // 두 스택의 내용을 바꿈
```
#### <strong>데크(Dequeue)</strong>
```
#include <deque>        // 헤더 파일

deque<TYPE> deque;      // 선언

deque.front();          // 첫 번째 원소 반환
deque.back();           // 마지막 원소 반환
deque.at(n);            // n번째 원소 반환
deque.push_front(e);    // 첫 위치에 e 추가
deque.push_back(e);     // 마지막 위치에 e 추가
deque.pop_front();      // 첫 번째 원소 삭제
deque.pop_back();       // 마지막 원소 삭제
deque.size();           // 덱의 크기 반환
deque.clear();          // 전체 원소 삭제
```